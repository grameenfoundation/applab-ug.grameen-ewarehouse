<!--(c) Copyright 2013 Grameen Foundation USA. All rights reserved-->
<apex:page tabStyle="SurveyManager__tab" standardController="gfsurveys__Survey__c" sidebar="false"
    extensions="gfsurveys.SurveyQuestionLogicController" language="{!$CurrentPage.parameters.lang}">

    <!-- Component -->
    <c:blockOverlay label="{!$Label.LOADING}..."/>

    <!-- Styles -->
    <style>
        .long_input, .short_input{
          width: 80%;
          background-color: #fff;
          -webkit-border-radius: 4px;
          -moz-border-radius: 4px;
          border-radius: 4px;
          border: 1px solid #000;
        }
        .long_input{height: 100px;}
        .short_input{height: 30px;}
        .number_input{
          height:20px;
          border:2px solid black;
          width:65%;
        }
        .container{height:40px;}
        .blankSpace{
          width: 1%;
          height: 30px;
          background-color: WhiteSmoke;
          -webkit-border-radius: 4px;
          -moz-border-radius: 4px;
          border-radius: 4px;
        }
        .colon{
          height: 30px;
          background-color: WhiteSmoke;
          font-weight: bold;
          padding-top: 7px;
        }
        .Qerrors {
          width: 100%;
          background-color: #FFCC99;
          -webkit-border-radius: 5px;
          -moz-border-radius: 5px;
          border-radius: 5px;
          padding: 8px;
          display: none;
          color: #000;
          font-weight: bold;
        }
        .cursor {cursor: pointer;}
        .questions{min-height:20px;}
        #content {width: 100%;}
        #buttons {margin:20px 2px;float:right;}
        .field-types div {cursor: pointer;}
        .buttonType {cursor: pointer;}



        textarea{resize:none;}

        div.optionsClass>div{margin-bottom:10px;}
        div.optionsClass>div>input{display:inline-block;width:400px;height:20px;border:2px solid black;margin-right:10px;}
        div.optionsClass>div>div{display:inline-block;margin-left:4px;}

        .option_caption{display:inline-block;margin:0px 10px 10px 4px;width: 15%;text-align:right;}
        .option_input{
          display:inline-block;
          background-color: #fff;
          -webkit-border-radius: 4px;
          -moz-border-radius: 4px;
          border-radius: 4px;
          border: 1px solid #000;
          width: 62%;
          height: 25px;
        }

        .single-multi_select{margin:0px 0px 5px 4px;}

        div.header div.actions{width:auto;float:right;}
        div.header div.sectionFooter{width:auto;float:right;}
        div.header div.actions>*{padding:0 4px;}
        div.header div.actions>span.disabled{color:#666;cursor:default;}

        label.error{font-family:sans-serif;color:red;}

        div.editable div.footer{margin:10px 10px 0; text-align:right;}

        div.number div.body div{display: block;}
        div.number div.body input[type=checkbox]{width:auto}

        #questionArea {margin:0 auto;background:#eee;min-width:770px;min-height:60px;}
        #questionArea>p {font-size:10pt;}

        div.section {margin-bottom:-16px;padding:2px;}
        div.section>div.header{margin:12px;padding:10px;overflow:hidden;}
        div.section>div.header .caption, div.section>div.header input[name=caption]{font-size:large;}

        div.question {margin:12px;padding:10px;}
        div.question input, div.question select{margin-left:10px;}

        div.question.readonly {background:#ddd;}
        div.question.readonly div.body {position:relative;padding:0 0 0 32px;color:#666;}
        div.question.readonly div.body p{margin:1px 0;}
        div.question.readonly div.body p:first-child{margin:3px 0;}
        div.question .caption{font-size:large;}
        div.question.readonly.text div.option label{min-width:100px;display:inline-block;text-align:right;}
        div.question.readonly div.tags{position:absolute;right:4px;bottom:0;color:#666;}
        div.question.readonly div.tags span{display: block;text-align:right;}
        div.question div.header {margin-left: 40px;}
        div.question div.header>div{display:inline-block;}
        div.question div.header div.name {margin-left:5px;color:#666;}
        div.question.readonly label.readonlyNegation{font-weight: bold; color: maroon;}

        div.questionAreaClass div.body {position:relative;color:#666;}
        div.questionAreaClass div.readonly div.body{padding:0 0 0 32px;}
        div.questionAreaClass div.body p{margin:1px 0;}
        div.questionAreaClass div.body p:first-child{margin:3px 0;}
        div.questionAreaClass label.readonlyNegation{font-weight: bold; color: maroon;}
        div.questionAreaClass div.header{position:relative;}
        div.questionAreaClass form {margin-left:-10px;}
        div.questionAreaClass div.body>form{margin-left:20px;}
        div.questionAreaClass a.conditionDelete{margin-left: 5px;}
        div.questionAreaClass div.conditions input[type=text]{width:145px;}
        div.questionAreaClass span.conditionNegation {display:inline-block; width: 60px;}

        div.question.editable{background:#fff;}
        div.question.editable, div.sectionHeader.editable {border:3px solid gray;}

        div.condition {display:block;}

        div.question.cut{background: none repeat scroll 0 0 #FFFFFF;border: 2px dashed gray;}
        div.currentTime{margin:0 80px}

        label.questionAutoNumber{margin-right:10px; margin-left:-40px; color:#6d6d6d;}
        label.sectionAutoNumber{ margin-right:10px; margin-left:2 0px; color:#6d6d6d;}
        .placeholderQuest {opacity:0.4;margin:12px;padding:10px;}
        .placeholderSec {opacity:0.4;margin-bottom:-16px;padding:2px}

        .avoidOverlap{margin-bottom:15px;}
        span.hidden{display:none}
        p.overlapCondition{color: red}
    </style>

    <!-- Use template -->
    <apex:composition template="gfsurveys__SurveyBuilderTemplate">
        <!-- Set variables to be used later -->
        <apex:define name="init">
            <apex:variable var="selectedTab" value="SKIPLOGIC"/>
            <apex:variable var="hasError" value="{!hasApexMessage}"/>
            <apex:variable var="isPublished" value="{!isPublished}"/>
            <apex:variable var="survey" value="{!survey}"/>
        </apex:define>

        <!-- Define the body -->
        <apex:define name="body">
            <div id="content">
                <div id="questionArea" class="questionAreaClass"></div>
            </div>

            <apex:form >
                <apex:outputText id="existing-questions" styleClass="existing-questions hidden" value="{!lastBatchOfQuestions}"/>
                <apex:outputText id="hasMoreQuestions" styleClass="hasMoreQuestions hidden" value="{!hasMoreQuestions}"/>
                <apex:outputText id="concurrentSaveArea" styleClass="concurrentSaveArea" style="display:none" value="{!concurrentSave}"/>

                <!-- Action functions -->
                <apex:actionFunction name="postSave"
                    action="{!save}"
                    oncomplete="afterPostSave()"
                    reRender="errorMessages, concurrentSaveArea">
                    <apex:param name="questions" value="" />
                    <apex:param name="quicksave" value="" />
                </apex:actionFunction>

                <!-- Get questions from controller in batches, so not to hit script statement limit -->
                <apex:actionStatus id="loadMoreQuestionsStatus" onstop="drawFetchedQuestions()"/>
                <apex:actionFunction name="loadMoreQuestions" action="{!loadMoreQuestions}"
                    reRender="existing-questions,hasMoreQuestions" status="loadMoreQuestionsStatus" >
                    <apex:param name="questions" value="" />
                </apex:actionFunction>
            </apex:form>
        </apex:define>
    </apex:composition>

    <!-- Scripts -->
    <script type="text/javascript">

        var gAllQuestionsAreLoaded = false;

        //create a format function for strings
        String.prototype.format = function(args) {
            return this.replace(/{(\d+)}/g, function(match, number) {
            return typeof args[number] != 'undefined'
                                            ? args[number]
                                            : match;
            });
        };
        $.fn.outerHTML = function(){

        // IE, Chrome & Safari will comply with the non-standard outerHTML, all others (FF) will have a fall-back for cloning
        return (!this.length) ? this : (this[0].outerHTML || (
            function(el){
               var div = document.createElement('div');
               div.appendChild(el.cloneNode(true));
               var contents = div.innerHTML;
               div = null;
               return contents;
            })(this[0]));

        }

        function canBeUsedAsSource(question){
            return (!isSection(question) && question.type != TYPE_STATIC) && (question.type != TYPE_FINAL);
        }

        //END LOGIC CONDITIONS
        var endConditions ={}; // mapping of question_code and the associated conditions

        // CONDITIONS
        var conditionText = {!conditions};

        //CONDITIONS THAT NEED EXTRA FIELD TO SPECIFY
        var conditionsWithValue = ["Is", "LesserThan", "GreaterThan"];

        //QUESTIONS IN WHICH EXTRA FIELD IS COMBO
        var questionsWithCombo = [TYPE_RADIO, TYPE_CHECKBOX];

        //QUESTIONS IN WHICH EXTRA FIELD IS NUMERIC
        var questionsWithNumberInteger = [TYPE_NUMBER_INTEGER];
        var questionsWithNumberDecimal = [TYPE_NUMBER_DECIMAL];

        //TYPES OF CONDITIONS
        var COMBO_TYPE = 'comboCondition';
        var NUMERIC_INTEGER_TYPE = 'numericIntegerCondition';
        var NUMERIC_DECIMAL_TYPE = 'numeriDecimalCondition';
        var STRING_TYPE = 'stringCondition';

        //attributes for numeric and string condition value fields
        var inputAttrs = new Array();
        inputAttrs[NUMERIC_INTEGER_TYPE] = {"placeholder":"{!$Label.PLEASE_TYPE_NUMBER}","class":NUMERIC_INTEGER_TYPE,"maxlength":"255"};
        inputAttrs[NUMERIC_DECIMAL_TYPE] = {"placeholder":"{!$Label.PLEASE_TYPE_NUMBER}","class":NUMERIC_DECIMAL_TYPE,"maxlength":"255"};
        inputAttrs[STRING_TYPE]  = {"placeholder":"{!$Label.PLEASE_TYPE_FILTER}","class":STRING_TYPE,"maxlength":"255"};

        //QUESTION SKIP CONDITION OPERATIONS
        var slBehavior = {!behaviors};

        var slOperator = {!operators};

        //OPERATORS
        var ALL_CONDITIONS = 'ALL';
        var ANY_CONDITION = 'ANY';
        // MAP EACH QUESTION TYPE WITH THE CONDITIONS THEY CAN HAVE
        var availableConditions = {};
        availableConditions[TYPE_TEXT]          = ['Answered','Is'];
        availableConditions[TYPE_TEXT_SHORT]    = ['Answered','Is'];
        availableConditions[TYPE_BARCODE]       = ['Answered','Is'];
        availableConditions[TYPE_TEXT_LONG]     = ['Answered','Is'];
        availableConditions[TYPE_TEXT_MULTI]    = ['Answered'];
        availableConditions[TYPE_NUMBER]        = ['Answered','Is','LesserThan','GreaterThan'];
        availableConditions[TYPE_NUMBER_INTEGER]= ['Answered','Is','LesserThan','GreaterThan'];
        availableConditions[TYPE_NUMBER_DECIMAL]= ['Answered','Is','LesserThan','GreaterThan'];
        availableConditions[TYPE_DATE]          = ['Answered'];
        availableConditions[TYPE_DATE_DATE]     = ['Answered'];
        availableConditions[TYPE_DATE_DATETIME] = ['Answered'];
        availableConditions[TYPE_RADIO]         = ['Answered','Is'];
        availableConditions[TYPE_CHECKBOX]      = ['Answered','Is'];

        var questions = new Array(); // Questions Array
        var isEditing = false; // Flag, limit the menu usage when a question is in edit or is new yet.
        var popupSave = false;

        // GENERAL PURPOSE HELPER METHODS
        function newId(){ return new Date().getTime().toString(36); }

        // removes all existing autonumbers, and adds new ones based on the order of the questions
        function setQuestionAutoNumber(){
            // Autonumber questions
            var i = 1;
            $('.questionAutoNumber').each(function(){$(this).text('Q' + (i++));});

            // Autonumber sections
            var s = 1;
            $('.sectionAutoNumber').each(function(){$(this).text('S' + (s++));});
        }

        // JQUERY VALIDATION ADDONS
        function hasSingleQuotes(value) { return value.indexOf("'") != -1; }
        function isEmpty(value){ return value == null || $.trim(value) == ''; }
        function isInteger(value){ return (value == parseInt(value, 10)) }
        function isDecimal(value){return(value == parseFloat(value))}
        var elemId;

        $.validator.addMethod('noSingleQuotes', function(value, element, param) {
            return !hasSingleQuotes(value);
        }, '{!$Label.SURVEY_LOGIC_ERR_QUOTES}');

        $.validator.addMethod('integer', function(value, element, param) {
            return isEmpty(value) || isInteger(value);
        }, '{!$Label.SURVEY_LOGIC_ERR_INVALID}');

        $.validator.addMethod('decimal', function(value, element, param) {
            return isEmpty(value) || isDecimal(value);
        }, '{!$Label.SURVEY_LOGIC_ERR_INVALID}');

        $.validator.addMethod('numeric', function(value, element, param) {
            return !isNaN(value);
        }, '{!$Label.SURVEY_LOGIC_ERR_NOT_NUM}');

        $.validator.addMethod('required', function(value, element, param) {
            return !isEmpty(value);
        }, '{!$Label.SURVEY_LOGIC_ERR_REQUIRED}');

        $.validator.addClassRules(STRING_TYPE,{"noSingleQuotes": true});
        $.validator.addClassRules(NUMERIC_INTEGER_TYPE,{"numeric": true, "required": true, "integer":true });
        $.validator.addClassRules(NUMERIC_DECIMAL_TYPE,{"numeric": true, "required": true, "decimal":true });

        //-------------------
        // READ-ONLY QUESTIONS
        //-------------------

        function getReadonlyDiv(question, div){
            var header  = getReadonlyHeader(question,div);
            var body    = getReadonlyBody(question);

            if (div == null) div = $('<div/>').attr('id',question.id);
            $(div).html('')
                .removeClass().addClass('question readonly ' + question.type.replace('-',' '))
                .append(header).append(body);
            return div;
        };

        function getReadonlyHeader(question, div){
            var div = $('<div/>').addClass('header');
            div.append('<div class="actions"/>');
            $('<div class="caption"/>')
                .text(question.caption)
                .prepend('<label class="questionAutoNumber"/>')
                .appendTo(div);
            div.append( $('<div/>',{"class":'name',"text":question.name}) );
            if (div != null && gAllQuestionsAreLoaded) appendEditLinks(); // means the question already exists on the page

            return div;
        };
        /**
        *   iterate over all the questions and a a tag when dependencies with
        *    end of survey questions exist
        *
        **/
        function appendLogicOverlaps(){
            //remove the previous tags
            $('.overlapCondition').remove();

            //add the tags when necessary
            for (i in questions){
                var div ;
                var currentQuestion = questions[i];
                var logicOverlap = validateLogicEndOfSurvey(currentQuestion);

                if (logicOverlap != ''){
                    div =  $('#'+ currentQuestion.id).find('.body');
                    div.append('<p class="overlapCondition">' +  format('{!$Label.BUILDER_ALERT_USED_CONDITION}',[logicOverlap])+ '</p>');
                }
            }

        }

        // Removes and adds edit links to all questions, except the first non-static question and all static questions before that
        function appendEditLinks(){
            // Remove all edit links from the page
            $('.action-edit').remove();

            $('.question, .section').each(function(i,elem){
                var qId = $(elem).attr('id');
                var question = questions[qId];

                // Get the list of questions that come before this one,
                // and filter out does that cannot be used as conditions for this one.
                previousQuestions = listAllPreviousQuestions(question);
                previousQuestions = filterPrevQuestions(previousQuestions[0], question);

                // If there are questions that can be used as condition, add the edit link to the question.
                if (!$.isEmptyObject(previousQuestions)){
                    var editLink = (question.originId != null && !question.remoteEditable)
                        ? '<span class="action-edit disabled" title="{!$Label.BUILDER_ERR_NONEDITABLEQUESTION}">{!$Label.EDIT}</span>'
                        : '<a class="action-edit" href="javascript: void(0)" onclick="editQuestion(\'' + qId + '\')">{!$Label.EDIT}</a>';
                    $(elem).find('.actions').first().append(editLink);
                }
            });
        }

        /** 2079
        * Check if exist a section before current
        * <p>
        * Verify there is any section sited before.
        *
        * @param question Question      Json Object Question
        * @return assertion Boolean     Assertion of verification
        */
        function existSectionBeforeCurrent(question)
        {
            for (id in questions){

                //is there a section before to the section of current question
                if (questions[questions[id].parent].position < questions[question.parent].position){

                    return true;
                }
            }

            return false;
        }

        //helper format function for strings
        function format(str,args){
            return str.replace(/{(\d+)}/g, function(match, number) {
            return typeof args[number] != 'undefined'
                                            ? args[number]
                                            : match;
            });
        }

        //helper function equals that ignore the case  for strings
        function equalsIgnoreCase(string1,string2){
            if (string1 == null || string2==null){
                return false;
            }
            else{
                return string1.toUpperCase() == string2.toUpperCase();
            }
        }

        function getReadonlyBody(question){
            var div = $('<div/>').addClass('body');

            // Describe all conditions
            var has_conditions = false;
            for(var key in question.skipconditions){
                var cond = question.skipconditions[key];
                var src  = questions[cond.sourceQuestionId];
                var p    = $('<p class="qReadOnlyConditions">');
                if (cond.negate == true){
                    p.append('<label class="readonlyNegation">{!$Label.NOT} </label>');
                }
                p.append( $('<b>',{"text":src.caption}) );
                p.append( ' ' + conditionText[cond.condition] + ' ' );
                if ($.inArray(cond.condition, conditionsWithValue) != -1){
                    if (conditionNeedsCombo(cond.sourceQuestionId)){
                        p.append( $('<b>',{"text":getConditionOption(cond)}) );
                    }else{
                        if (conditionNeedsNumericInteger(cond.sourceQuestionId)||conditionNeedsNumericDecimal(cond.sourceQuestionId)){
                                cond.value = cond.value * 1;
                            }
                        p.append( $('<b>',{"text":cond.value}) );
                    }
                }
                div.append(p);
                has_conditions = true;
            }
            var visibility = slBehavior[question.skipLogicBehavior];
            var operator = slOperator[question.skipLogicOperator];
            div.prepend( has_conditions
                         ? format('<p class="condVisibility"><b>{!$Label.THIS_WHEN}</b></p>',[visibility,operator])
                         : '<p class="condVisibility"><b>{!$Label.SURVEY_LOGIC_ALWAYS_SHOW}</b></p>' );

            if(gAllQuestionsAreLoaded){
                var logicOverlap = validateLogicEndOfSurvey(question);
                if (logicOverlap != ''){
                    div.append('<p class="overlapCondition">' +  format('{!$Label.BUILDER_ALERT_USED_CONDITION}',[logicOverlap])+ '</p>')
                }
            }
            return div;
        };

        function getConditionOption (condition){
            var question = questions[condition.sourceQuestionId];
            for (var opt in question.options){
                if (question.options[opt].id == condition.value){
                    return question.options[opt].caption;
                }
            }
        }

        // helper method to trim and remove extra spaces from text inputs
        function removeExtraSpaces(){ removeInputExtraSpaces(this) }
        function removeInputExtraSpaces(input) { $(input).val( $.trim($(input).val().replace(/\s+/g,' ')) ); }

        // helper method to create dropdowns
        function _dropdown(cls,pname, options, def){
            dropdown = $('<select/>',{"class":cls, "name":pname,"size":"1"});
            for (var key in options)
                dropdown.append('<option value="' + key + '">' + htmlEncode(options[key]) + '</option>');
            $(dropdown).find('option[value="' + def + '"]').attr('selected','selected');
            return dropdown;
        }

        function _input(pname, plabel, pdefault, pattributes) {
            var attributes = {"name":pname, "type":'text', "value":(pdefault != null ? pdefault : ''), "blur":removeExtraSpaces};
            $.extend(attributes, pattributes)
            var input = $('<input/>',attributes);
            var div = $('<div/>').addClass(pname)
                    .append('<label for="' + pname + '">' + plabel + '</label>')
                    .append( input );
            return div;
        }

        function getEditableBody(question){
            var div = $('<div/>').addClass('body');
            var form = $('<form/>',{"id":'form' + question.id,"method":'GET'});

            var skipOperations = $('<div/>').addClass('skipOperations');
            var skipLogicBehavior = _dropdown('skipLogicBehavior','skipLogicBehavior', slBehavior, question.skipLogicBehavior);
            var skipLogicOperator = _dropdown('skipLogicOperator','skipLogicOperator', slOperator, question.skipLogicOperator);
            skipOperations.append(
                '<p>{!$Label.SURVEY_LOGIC_WHEN_CONDITIONS}</p>'
                .format([skipLogicBehavior.outerHTML(),skipLogicOperator.outerHTML()]));

            // List all conditions
            var conditions = $('<div/>').addClass('conditions');

            for (key in question.skipconditions)
                conditions.append( getEditableSkipCondition(question, question.skipconditions[key]) );

            // Button for adding more conditions

            var morebutton = $('<input/>',{
                "type":'button',
                "name":'addCondition',
                "value":'{!$Label.SURVEY_LOGIC_ADD_CONDITION}',
                "class":'addConditionBtn',
                "click":function(){ getEditableSkipCondition(question,{"id":newId()}).appendTo(conditions); }
            });

            var footer = '<div class="footer">'
                       + '<a id="cancelEditLink" href="javascript: void(0)" onclick="cancelEdit(\'' + question.id + '\');return false;">{!$Label.CANCEL}</a>'
                       + '<input id="submitEdit" type="submit" value="{!$Label.DONE}"/>'
                       + '</div>';

            $(form).validate({
                "submitHandler": function(form){ acceptEdit(question.id); }
            });
            return div.append( form.append(skipOperations).append(conditions).append(morebutton).append(footer) );
        }

        /**
        * Apply filter to All Previous Options of Questions for Condtitions of Logic
        * <p>
        * Reduce all available Previous options of questions for conditions depending of some factors.
        * (Related issue: 2079)
        *
        * @param prevQuestions JsObject     All previous conditions
        * @param question Question          Current Question Object. Must not be null.
        * @return prev options              Filtered options of questions for conditions
        */
        function filterPrevQuestions(prevQuestions, question){

            //result for filtered previous options of questions for conditions
            var prev = {};

            // Avoid further processing if prevQuestions is already empty.
            if ($.isEmptyObject(prevQuestions))  return prev;

            var parentQuestion = question.parent;

            // Iterate over each question in the list of previous questions and ensure
            // it can be used as condition for this particular question.
            for (id in prevQuestions){
                prevQuestion = questions[id];
                if ( isSection(prevQuestion) ) continue; // Sections cannot be used as source questions.

                // Can use a question as condition.
                prevParent = questions[prevQuestion.parent];

                var canBeDependence = true;

                //if previous question belongs to a repeat section and it doesn't belong to current
                //parent this one can't be a dependence.
                canBeDependence = (canBeDependence
                                    && !(prevParent.type == TYPE_REPEAT
                                    && prevParent.id != question.parent));

                //if previous question belongs to a section with "Show all questions in one page" option enabled
                //and it sites in same parent this one can't be a dependence.
                canBeDependence = (canBeDependence
                                    && !(prevParent.samePage
                                    && prevParent.id == question.parent));

                if(canBeDependence)
                    prev[id] = prevQuestions[id];
            }
            return prev;
        }

        /**
        * Generate all Previous Condtitions of Logic for a question
        * <p>
        * Create a list containing all previous condition of source.
        * (Related issue: 2079)
        *
        * @param question Question          Current Question Object
        * @return option, first question    All previous options of questions and identify the first question
        */
        function listAllPreviousQuestions(question)
        {
            prevQuestions = {};             // all questions prior to the parameter question
            firstQuestion = null;           // id of the first question in the survey
            currentQuestionAutonumber = 0;  // keep track of the current question number (count questions only)

            // Iterate over all questions until we reach the current one.
            // Add all that can be used as soure to the list of previous questions.
            $('.question, .section').each(function(i,elem){
                var otherId = $(elem).attr('id');
                if (otherId == question.id) return false;   // reached this same question, about loop.

                var otherQuestion = questions[otherId];
                if (isSection(otherQuestion)) return true; // sections cannot be source questions, skip to the next one.

                // Increase autonumber for current question..
                currentQuestionAutonumber++;

                // Store first question's id that could be used as a condition(I mean this must not be static, this was fixed in #2410)

                if (firstQuestion == null  && canBeUsedAsSource(otherQuestion))
                    firstQuestion = otherId;

                if (canBeUsedAsSource(otherQuestion))
                    prevQuestions[otherId] = 'Q' + currentQuestionAutonumber + ' ' + otherQuestion.caption;
            });

            // Return possible previous options of questions and the first question
            return [prevQuestions, firstQuestion];
        }

        /**
        * Draw the form to set skip conditions
        * <p>
        * Create a form for assigning skip conditions to a question
        * and draw it on the screen.
        *
        * @param question Question      Json Object for Question
        * @param condition Condition    Json Object for one condition of Question
        * @return div HTML container    HTML container within all controls fo condition for that question
        */
        function getEditableSkipCondition(question, condition){
            var div = $('<div/>').addClass('condition').attr('id',condition.id);

            var checked = '';
            var bold = '';
            if(condition.negate){
                checked = 'checked';
                bold = 'bold';
            }
            var negation = $('<span/>').addClass('conditionNegation').append('<input class="chkNegate" type="checkbox" onclick="toggleLabel($(this));" name="negate" value="true" ' + checked + '>').append('<label class="lblNot" style="font-weight:' + bold + '"> {!$Label.NOT} </label>');
            div.append(negation);

            var prevData = listAllPreviousQuestions(question);

            // will store the first question (default one) to later build the condition combo based on it
            var firstQuestion = prevData[1];

            // List all prevoius questions
            var prevquestions = prevData[0];

            prevquestions = filterPrevQuestions(prevquestions, question);

            var questionsdropdown = _dropdown('sourceSelectList','source', prevquestions, condition ? condition.sourceQuestionId : null);
            div.append(questionsdropdown);

            var conditiondropdown = $('<select/>',{"class":'condSelectList', "name":"cond","size":"1"});
            fillConditionDropdown(conditiondropdown, condition.sourceQuestionId ? questions[condition.sourceQuestionId].type : questions[firstQuestion].type, condition.condition);
            div.append(conditiondropdown);

            // if this condition requires an extra field, checks if it is a combo or a text field and creates it
            if ($.inArray(condition.condition, conditionsWithValue) != -1){
                var sourceQuestion = $(questionsdropdown).val();
                if (conditionNeedsCombo(sourceQuestion)){
                    div.append(getOptionCombo(sourceQuestion, condition));
                }else{
                    div.append( $('<input/>',{"name":"value-" + condition.id,"id":"value-" + condition.id, "value":condition.value, "type":"text"}).attr( inputAttrs[getClassNeeded(sourceQuestion)] ));
                }
            }

            div.append('<a href="javascript: void(0)" class="conditionDelete" onclick="deleteCondition(\'' + condition.id + '\')">{!$Label.DELETE}</a>');

            questionsdropdown.change(function(){
                fillConditionDropdown(conditiondropdown, questions[$(this).val()].type);
                conditiondropdown.change();
            });

            conditiondropdown.change(function(){

                var inputName = $(div).find('[name^="value"]');
                if ($.inArray($(this).find('option:selected').val(), conditionsWithValue) != -1){

                    var sourceQuestion = $(div).find('[name=source]').val();
                    var neededClass = getClassNeeded(sourceQuestion);
                    var existingInput = $(div).find('[name^="value"]:not(.' + neededClass + ')');

                    // if there is an input not needed, deletes it and creates the corresponding one
                    if (existingInput.length){
                        existingInput.remove();
                        var newInput = createNewInput (neededClass, condition, sourceQuestion);
                        $(this).after(newInput);
                    }else{
                        // if there is no input at all, creates the corresponding one
                        if (!inputName.length){
                            var newInput = createNewInput (neededClass, condition, sourceQuestion);
                            $(this).after(newInput);
                        }else if (neededClass==COMBO_TYPE) {
                            inputName.remove();
                            var newInput = createNewInput (neededClass, condition, sourceQuestion);
                            $(this).after(newInput);
                        }
                    }
                }else{
                    inputName.remove();
                }
            });
            fixMarginIe8(question.id);
            return div;
        }

        // This method add a class(that ensures that the first applied condition doesn't overlap in IE8) when the conditions are given
        function fixMarginIe8(questionId){
            // Gets user browser
            if (/MSIE (\d+\.\d+);/.test(navigator.userAgent)){
                var ieversion = new Number(RegExp.$1); // capture x.x version and store it as a number
                if (ieversion == 8){
                     $('#' + questionId + ' .conditions').addClass('avoidOverlap');
                }
            }
        }

        // gets the class of the needed input
        function getClassNeeded (sourceQuestion){
            if (conditionNeedsCombo(sourceQuestion)){
                return COMBO_TYPE;
            }else if (conditionNeedsNumericInteger(sourceQuestion)){
                return NUMERIC_INTEGER_TYPE;
            }else if(conditionNeedsNumericDecimal(sourceQuestion)){
                return NUMERIC_DECIMAL_TYPE
            }else{
                return STRING_TYPE;
            }
        }

        // defines if the referenced question needs a combo
        function conditionNeedsCombo (sourceQuestion){
            var question = questions[sourceQuestion];
            return $.inArray(question.type, questionsWithCombo) != -1;
        }

        // defines if the referenced question needs a numeric field
        function conditionNeedsNumericInteger (sourceQuestion){
            var question = questions[sourceQuestion];
            return $.inArray(question.type, questionsWithNumberInteger) != -1;
        }
        function conditionNeedsNumericDecimal(sourceQuestion){
            var question = questions[sourceQuestion];
            return $.inArray(question.type, questionsWithNumberDecimal) != -1;
        }

        // creates the needed input depending on the needed class
        function createNewInput (neededClass, condition, sourceQuestion){
            if (neededClass == COMBO_TYPE){
                return getOptionCombo(sourceQuestion, condition);
            }else{
                return $('<input/>',{"name":"value-" + condition.id,"id":"value-" + condition.id, "type":"text"}).attr( inputAttrs[neededClass] );
            }
        }

        // creates a dropdown list containing a question's options
        function getOptionCombo (questionId, condition){

            var question = questions[questionId];
            var options = new Array();
            for (var key in question.options){
                var option = question.options[key];
                  var caption = option.caption;
                  if (caption.length >= 40)
                   caption = caption.substring(0,40) + '...';
                  options[option.id] = caption;
            }

            var resultCombo = _dropdown('questionsOptions','value-' + condition.id, options, condition.value);
            resultCombo.addClass(COMBO_TYPE);
            return resultCombo;
        }

        // changes the state of the "NOT" label
        function toggleLabel(element){

            var ischecked = $(element).is(':checked');
            $(element).next().css('font-weight', ischecked ? 'bold' : '');
        }

        // gets the selected condition and removes it from the DOM (later, saveToQuestion method persists this change)
        function deleteCondition (conditionId){
            $('#' + conditionId).remove();
        }

        function fillConditionDropdown(dropdown, type, def){
            if (def == null) def = $(dropdown).val();

            var avConditions = {};
            for(i in availableConditions[type]){
                var key = availableConditions[type][i];
                avConditions[key] = conditionText[key];
            }

            $(dropdown).html('');
            for (var key in avConditions)
                $(dropdown).append('<option value="' + key + '">' + htmlEncode(avConditions[key]) + '</option>');
            $(dropdown).val(def);

            return dropdown;
        }

        // Returns a new question, parsed from editable div
        function saveToQuestion(div){
            var id = $(div).attr('id');
            var question = questions[id];

            question.skipconditions = new Array();
            div.find('.condition').each(function(i,elem){
                var condition = {
                    "id"              :$(elem).attr('id'),
                    "sourceQuestionId":$(elem).find('[name=source]').val(),
                    "condition"       :$(elem).find('[name=cond]').val(),
                    "value"           :$(elem).find('[name^=value]').val(),
                    "negate"          :$(elem).find('[name=negate]').is(':checked') ? true : false
                };
                question.skipconditions.push(condition);
            });
            question.skipLogicBehavior = $(div).find('[name="skipLogicBehavior"]').val();
            question.skipLogicOperator = $(div).find('[name="skipLogicOperator"]').val();
            questions[id] = question;
            return question;


        };
        //validate that a logic set for a question is not the same as one from a previous TYPE FINAL question
        //and warn the user about it
        function validateLogicEndOfSurvey(question){
            var finalQuestionSameLogic = '';
            for (i in questions) {

                var otherQuestion = questions[i];

                if (question.skipLogicBehavior == otherQuestion.skipLogicBehavior
                    //the otherQuestion must be an end of survey
                    && otherQuestion.type == TYPE_FINAL
                    //check that the otherQuestion is previous to the question
                    && (comparePosition(question,otherQuestion)==1)){
                            //separate cases to show the error msg

                        finalQuestionSameLogic = conditionsOverlap(question, otherQuestion);
                }
                //if a condition exist finish the loop
                if (finalQuestionSameLogic != ''){
                            break;
                }
            }
            return finalQuestionSameLogic;
        }
        /**
        * Check if a question end of survey overlaps a question returns the question name if it
        * overlaps
        *
        */
        function conditionsOverlap(question, otherQuestion){
            var showmessage = false;
            var finalQuestionSameLogic = '';
            if (equalsIgnoreCase(otherQuestion.skipLogicOperator,ALL_CONDITIONS)
                && equalsIgnoreCase(question.skipLogicOperator,ANY_CONDITION)){
                //if has one repeated logic show message

                for(j in otherQuestion.skipconditions){
                    if (conditionInQuestion(otherQuestion.skipconditions[j], question)){
                        showmessage=true;
                        finalQuestionSameLogic  = otherQuestion.name;
                        break;
                    }
                }


            }else if(equalsIgnoreCase(question.skipLogicOperator,ANY_CONDITION)
                && equalsIgnoreCase(otherQuestion.skipLogicOperator,ANY_CONDITION)){

                //if the source question has all the conditions of the end of survey question included show message
                showmessage=true;
                for(j in otherQuestion.skipconditions){
                    if (!(conditionInQuestion(otherQuestion.skipconditions[j], question))){
                        showmessage=false;
                        break;
                    }
                }
                if (showmessage){
                    finalQuestionSameLogic  = otherQuestion.name;
                }

            }else if (equalsIgnoreCase(otherQuestion.skipLogicOperator,ALL_CONDITIONS)
                && equalsIgnoreCase(question.skipLogicOperator,ALL_CONDITIONS)){
                //if the finalize question has all the conditions of source question included show message
                if (question.skipconditions.length != 0){
                    showmessage=true;
                    for(j in question.skipconditions){
                        if (!(conditionInQuestion(question.skipconditions[j], otherQuestion))){
                            showmessage=false;
                            break;
                        }
                    }
                    if (showmessage){
                        finalQuestionSameLogic  = otherQuestion.name;
                    }
                }

            }
            return finalQuestionSameLogic;
        }
        /**
        * Check if a condition is set in a question and returns
        * true if the conditions exists
        *
        */
        function conditionInQuestion(condition,question){
            for(i in question.skipconditions){
                var localCondition = question.skipconditions[i];
                if (condition.sourceQuestionId == localCondition.sourceQuestionId
                    && condition.condition == localCondition.condition
                    && condition.value == localCondition.value
                    && condition.negate == localCondition.negate){
                        return true;
                }
            }
            return false;
        }
         /**
        * Compares position of question against other question.
        * @return 0 if both questions are the same or if a question is in a section
        *         a negative number if question comes before otherQuestion,
        *         a positive number if question comes after otherQuestion.
        */
    function comparePosition(question, otherQuestion){
        var position;
        if (isSection(question) && isSection(otherQuestion) ){
            if(question.position > otherQuestion.position){
                position=1;
            }else if(question.position == otherQuestion.position) {
                    position=0;
            }else{
                position=-1;
            }

        }else if (isSection(question) && !isSection(otherQuestion)){
        // the position of the parent must be minor, or if the parent position
                    //is the same,the otherQuestion must be minor than question
                    //this is to check that otherQuestion is previous to the actual question
                var otherParent = questions[otherQuestion.parent];
                if(question.position > otherParent.position){
                    position=1;
                }else if(question.position == otherParent.position) {
                    position=0;
                }else{
                    position = -1;
                }
        }else if(!isSection(question) && isSection(otherQuestion)){
                var parent = questions[question.parent];
                if(parent.position > otherQuestion.position){
                    position=1;
                }else if(otherQuestion.position == parent.position) {
                    position=0;
                }else{
                    position = -1;
                }
        }else if(!isSection(question) && !isSection(otherQuestion)){
            var otherParent = questions[otherQuestion.parent];
            var parent = questions[question.parent];
            if (parent.position > otherParent.position){
                position = 1;
            }else if (otherParent.position == parent.position){
                if(question.position > otherQuestion.position){
                    position=1;
                }else if(question.position == otherQuestion.position) {
                    position=0;
                }else{
                    position = -1;
                }
            }else {
                position = -1;
            }
        }

        return position;
    }
        //----------------
        // SECTION HEADERS
        //----------------

        function sectionReadonlyHeader(section, div){
            if (div == null) div = $('<div/>');
            div.html('').addClass('header readonly tertiaryPalette sectionHeader');
            $('<span class="caption sectionCaption"/>')
                .text(section.caption)
                .prepend('<label class="sectionAutoNumber"/>')
                .appendTo(div);

            if (section.type  == TYPE_REPEAT){
                $('<span />')
                    .text('({!$Label.SECTION_REPEAT})')
                    .css({
                        'color' : '#ff0000',
                        'font-size' : 'small',
                        'margin-left' : '10px'})
                    .appendTo(div);
            }

            div.append('<div class="actions"/>');
            //append section skip conditions
            div.append( getReadonlyBody(section))

            return div;
        }

        function editMode(value){
            isEditing = value;
            $('.actions').toggle(!value);
        }

        //-------------
        // USER ACTIONS
        //-------------

        function addSection(section){
            var div = $('<div/>',{"id":section.id, "type":TYPE_SECTION}).addClass('section')
                .append( sectionReadonlyHeader(section,null) )
                .append('<div class="questions"></div>');

            $('#questionArea').append(div);
            div.hide().fadeIn(null);
        }


        // called from "edit" links
        function editQuestion(questionId){

            toggleEditable(questionId,true);
        };

        //------------------
        // ACTION COMPLETION
        //------------------
        $(document).ready(function(){
            //IE8 fix for popup that shows when leaving a page
            if ( $.browser.msie && (parseInt($.browser.version, 10) == 8) ) {
                window.onbeforeunload = null;
            }

            drawFetchedQuestions();
        });

        /**
         * Draws the questions that the survey got from the database in the last batch.
         */
        function drawFetchedQuestions () {
            var existing_questions = $('.existing-questions');
            var to_draw = $.parseJSON( existing_questions.text() );
            existing_questions.empty();

            if (to_draw == null || to_draw.length == 0) {
                // create the first section if there are none
                var sections = $('#questionArea').find('.section');
                if( sections.size() == 0 )
                    editMode(false);
            } else {

                // fill the questions array first so sections with skip conditions related to other questions can be correctly drawn
                for (i in to_draw) {
                    var question = to_draw[i];
                    question.type = question.type.toLowerCase();    // Lower-case the type
                    questions[question.id] = question;              // Add the question to the questions array
                }

                for (i in questions) {
                    var question = questions[i];

                    if (isSection(question)){             // Draw the question
                        addSection(question);
                    }
                    else {
                        var div = getReadonlyDiv(question)
                        $('#'+question.parent+' .questions').append(div);

                        //in case the type is end_of_survey we append an information icon to notify the user
                        if (questions[question.id].type == 'end_of_survey'){
                            div.find('.header').append('&nbsp;&nbsp;<img src="/img/alohaSkin/help_orange.png" title="{!$Label.END_OF_SURVEY_INFO}">');
                        }
                    }
                }
            }

            if ($('.hasMoreQuestions').text() == 'true') {
                blockPage();
                loadMoreQuestions();
            } else {
                unblockPage();
                afterAllQuestionsFetched();
            }
        }

        function afterAllQuestionsFetched(){

            setQuestionAutoNumber();
            appendLogicOverlaps();
            appendEditLinks(); //these are not appended after the first run, so have to add them manually
            $($('.question')[0]).find('a').remove();
            gAllQuestionsAreLoaded = true;
        }

        // called from "cancel" link on Editable view
        function cancelEdit(questionId){
            hasUnsavedChanges = false;
            toggleEditable(questionId,false);
        };

        function toggleEditable(questionId, editable){
            var question = questions[questionId];
            var div = $('#' + questionId);

            if(isSection(question))
                div = div.find('div.sectionHeader');

            div.hide().toggleClass('readonly',!editable).toggleClass('editable',editable);
            div.find('.body').remove();
            editMode(editable);

            var toAppend = editable ? getEditableBody(question) : getReadonlyBody(question) ;
            div.append(toAppend);

            div.fadeIn(null);
        }

        // called from "done" link on Editable view
        function acceptEdit(questionId){

            var div = $('#' + questionId);
            //check if the question was changed
            var prevQuestion = questions[questionId];

            hasUnsavedChanges = hasChanges(prevQuestion,div);
            var question = saveToQuestion(div);



            //if the question is a TYPE_FINAL reload the logic overlap tags
            if (question.type == TYPE_FINAL){
                appendLogicOverlaps();
            }
            toggleEditable(questionId,false);


        }

        //check if a questionhas changes
        function hasChanges(question, div){
            var changes = false;

            if(question.skipconditions.length != div.find('.condition').length){
                changes = true;
            }else if (question.skipLogicBehavior != $(div).find('[name="skipLogicBehavior"]').val()
                || question.skipLogicOperator != $(div).find('[name="skipLogicOperator"]').val()){
                changes = true;
            }else{
                div.find('.condition').each(function(i, elem){
                    if (question.skipconditions[i].sourceQuestionId != $(elem).find('[name=source]').val()
                         || question.skipconditions[i].condition != $(elem).find('[name=cond]').val()
                         || question.skipconditions[i].value != $(elem).find('[name^=value]').val()
                         || question.skipconditions[i].negate != $(elem).find('[name=negate]').is(':checked')){
                        changes = true;
                    }
                });
            }
            return changes;
        }

        function save(quicksave){
            // Validate is not editing
            if(isEditing){
                 alert('{!JSENCODE($Label.BUILDER_ERR_CANNOTSAVEWHILE)}'.replace('{0}', '{!$ObjectType.Question__c.LabelPlural}').replace('{1}', 'edited'));
                 popupSave = false;
                 return false;
            }
            else {
                // Set unsaved changes in false after save
                hasUnsavedChanges = false;
                // generate the array of questions
                var arr = new Array();
                for(var i in questions){
                    var question = questions[i];
                    if (question.originId == null || question.remoteEditable)
                        arr.push(JSON.stringify(question));
                }
                var json = '[' + arr.join(',') + ']';
                blockPage();
                postSave(json,!quicksave);
                return false;
            }
        }
        function afterPostSave(){
            unblockPage();
            hasUnsavedChanges = false;
            concurrentSavePopup();
            var errorMessage = $('.message').attr('class');
            // If has errors do not save and has unsaved changes
            hasUnsavedChanges = errorMessage != undefined;
            //If do not have error message do redirect
            if(popupSave && redirect && !hasUnsavedChanges) doRedirect();
        }
    </script>
</apex:page>